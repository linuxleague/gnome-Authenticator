use crate::config;
use once_cell::sync::Lazy;
use secret_service::{Collection, EncryptionType, Error, SecretService};
use std::collections::HashMap;

static SECRET_SERVICE: Lazy<SecretService<'static>> = Lazy::new(|| {
    SecretService::new(EncryptionType::Dh)
        .expect("A running secret-service is required for Authenticator")
});

pub struct Keyring;

fn token_attributes(token_id: &str) -> HashMap<&str, &str> {
    let mut attributes = HashMap::new();
    attributes.insert("application", config::APP_ID);
    attributes.insert("type", "token");
    attributes.insert("token_id", &token_id);
    attributes
}

fn password_attributes() -> HashMap<&'static str, &'static str> {
    let mut attributes = HashMap::new();
    attributes.insert("application", config::APP_ID);
    attributes.insert("type", "password");
    attributes
}

fn random_salt() -> [u8; 64] {
    use rand::RngCore;

    let mut salt = [0u8; 64];
    rand::thread_rng().fill_bytes(&mut salt);
    salt
}

fn encode_argon2(secret: &str) -> anyhow::Result<String> {
    use argon2::Config;

    let password = secret.as_bytes();
    let salt = &random_salt();
    let config = Config::default();
    let hash = argon2::hash_encoded(password, salt, &config)?;

    Ok(hash)
}

/// Verifies that the hash generated by `password` corresponds
/// to `hash`.
fn verify_argon2(hash: &str, password: &str) -> anyhow::Result<bool> {
    Ok(argon2::verify_encoded(hash, password.as_bytes())?)
}

impl Keyring {
    pub fn get_default_collection<'a>() -> Result<Collection<'a>, Error> {
        let collection = match SECRET_SERVICE.get_default_collection() {
            Err(Error::NoResult) => SECRET_SERVICE.create_collection("default", "default"),
            e => e,
        }?;

        Ok(collection)
    }

    pub fn ensure_unlocked() -> Result<(), Error> {
        let collection = Self::get_default_collection()?;
        collection.unlock()?;

        Ok(())
    }

    pub fn store(label: &str, token: &str) -> anyhow::Result<String> {
        let col = Self::get_default_collection()?;
        let token_id = encode_argon2(token)?;
        let attributes = token_attributes(&token_id);
        let base64_encoded_token = hex::encode(token.as_bytes());
        col.create_item(
            label,
            attributes,
            base64_encoded_token.as_bytes(),
            true,
            "text/plain",
        )?;
        Ok(token_id)
    }

    pub fn token(token_id: &str) -> Result<Option<String>, Error> {
        let col = Self::get_default_collection()?;

        let attributes = token_attributes(token_id);
        let items = col.search_items(attributes)?;
        Ok(match items.get(0) {
            Some(e) => Some(String::from_utf8(hex::decode(e.get_secret()?).unwrap()).unwrap()),
            _ => None,
        })
    }

    pub fn remove_token(token_id: &str) -> Result<(), Error> {
        let col = Self::get_default_collection()?;

        let attributes = token_attributes(token_id);
        let items = col.search_items(attributes)?;
        match items.get(0) {
            Some(e) => e.delete(),
            _ => Err(Error::NoResult),
        }
    }

    pub fn has_set_password() -> Result<bool, Error> {
        let col = Self::get_default_collection()?;

        let attributes = password_attributes();
        match col.search_items(attributes) {
            Ok(items) => Ok(matches!(items.get(0), Some(_))),
            _ => Ok(false),
        }
    }

    /// Stores password using the Argon2 algorithm with a random 128bit salt.
    pub fn set_password(password: &str) -> anyhow::Result<()> {
        let col = Self::get_default_collection()?;

        let encoded_password = encode_argon2(password)?;
        let attributes = password_attributes();
        col.create_item(
            "Authenticator password",
            attributes,
            encoded_password.as_bytes(),
            true,
            "plain",
        )?;
        Ok(())
    }

    pub fn reset_password() -> Result<(), Error> {
        let col = Self::get_default_collection()?;

        let attributes = password_attributes();
        let items = col.search_items(attributes)?;

        match items.get(0) {
            Some(i) => i.delete(),
            None => Err(Error::NoResult),
        }
    }

    pub fn is_current_password(password: &str) -> anyhow::Result<bool> {
        let col = Self::get_default_collection()?;

        let attributes = password_attributes();
        let items = col.search_items(attributes)?;
        Ok(match items.get(0) {
            Some(i) => {
                let secret = &i.get_secret()?;
                let stored_pass = std::str::from_utf8(secret)?;
                verify_argon2(stored_pass, password)?
            }
            None => false,
        })
    }
}
